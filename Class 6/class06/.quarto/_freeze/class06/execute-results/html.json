{
  "hash": "5b07cfbb1fcc539a4349acb11fec1bcb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Class 6: R Functions Lab\"\nauthor: \"Michael Romero (A18135877)\"\nformat: html\n---\n\nAll functions in R have at least 3 things:\n\n-A **name** we pick this and use it to call the function. - Input **arguments**, there can be multiple comma separated inputs ot the function - The **body**, lines of R code that do the work of the function\n\nOur first wee function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd<-function(x, y=1) {\n  x+y\n}\n```\n:::\n\n\nLets test our function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd(c(1,2,3), y=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 12 13\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd(10,100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 110\n```\n\n\n:::\n:::\n\n\n## A second function\n\nLet's try something more interesting. Make a sequence generation tool.\n\nThe `sample()` function could be useful here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(1:10, size= 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 3 1\n```\n\n\n:::\n:::\n\n\nchange this to work with the nucleotides A C G and T\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn<-c(\"A\",\"C\",\"T\",\"G\")\nsample(n, size=5, replace = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"G\" \"A\" \"A\" \"G\" \"A\"\n```\n\n\n:::\n:::\n\n\nTUrn this snippet into a function that returns a user specified length dna sequence. Let's call it `generate_dna()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna<-function(len=10, fasta=FALSE) {\n  n<-c(\"A\",\"C\",\"T\",\"G\")\n  v<- sample(n, size=len, replace = TRUE)\n  \n  # Make a single element vector\n  s<-paste(v, collapse=\"\")\n  \n  cat(\"Well done you!\")\n  \n  if(fasta) {\n return(s)    \n  }else{\n    return(v)\n  }\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWell done you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"C\" \"T\" \"A\" \"G\" \"T\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns<-generate_dna(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWell done you!\n```\n\n\n:::\n\n```{.r .cell-code}\ns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"G\" \"G\" \"T\" \"G\" \"T\" \"A\" \"A\" \"G\" \"T\" \"C\" \"G\" \"C\" \"G\" \"C\"\n```\n\n\n:::\n:::\n\n\nI want the option to return a single element character vector with my sequence all together like this: \"GGAGTAC\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna(10, fasta=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWell done you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"C\" \"A\" \"A\" \"C\" \"A\" \"T\" \"C\" \"C\" \"T\" \"A\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna(10, fasta=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWell done you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TCGGAGTACC\"\n```\n\n\n:::\n:::\n\n\n## A more advanced example\n\nMake a third function that generates protein sequence of a user specified length and format. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna<-function(size=20, fasta=FALSE) {\n  n<-c(\"A\",\"C\",\"T\",\"G\")\n  v<- sample(n, size=size, replace = TRUE)\n  \n  # Make a single element vector\n  s<-paste(v, collapse=\"\")\n  \n  cat(\"Well done you!\")\n  \n  if(fasta) {\n return(s)    \n  }else{\n    return(v)\n  }\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWell done you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"T\" \"C\" \"G\" \"T\" \"G\" \"C\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_protein<-function(size=15, fasta=TRUE) {\n  aa<-c(\"A\",\"R\",\"N\",\"D\",\"C\",\"Q\",\"E\",\"G\",\"H\",\"I\",\"L\",\"K\",\"M\",\"F\",\"P\",\"S\",\"T\",\"W\",\"Y\",\"V\")\n  seq<-sample(aa, size=size, replace=TRUE)\n  \n  if (fasta) {\n    return(paste(seq, collapse=\"\"))\n  } else{\n    return(seq)\n    }\n}\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_protein(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NDKPR\"\n```\n\n\n:::\n:::\n\n\n>Q. generate random protein sequences between lengths 5 and 12 amino acids.\n\n\nOne approach is to do this by brute force calling our function for each length 5 to 12.\n\nAnother approach is to write a `for()` loop to itterate over the input valued 5 to 12\n\nA very useful third R specific approach is to use the `sapply()` function.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(5:12, generate_protein)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"INKLY\"        \"MEGNHD\"       \"VTYWWWE\"      \"QISYFKIN\"     \"LKNSRLAME\"   \n[6] \"HQMRDRNLRE\"   \"WEYNCCPTWYD\"  \"QFEFSCESDPFR\"\n```\n\n\n:::\n:::\n\n\n>**Key-Point**: Writing functions in R is doable but not the easiest thing. Starting with a working snippet of code and then using LLM tools to imporve and generalize your function code is a productive approach. ",
    "supporting": [
      "class06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}